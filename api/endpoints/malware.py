"""
Malware Analysis API Endpoint
---------------------------
API endpoint for malware analysis using the DefensysAI malware detection model.
"""
import os
import time
import hashlib
import logging
import tempfile
import shutil
from typing import Dict, Any, Optional, List
from fastapi import (
    APIRouter, 
    HTTPException, 
    Depends, 
    BackgroundTasks, 
    UploadFile, 
    File, 
    Form,
    Request
)

from api.models.schemas import (
    MalwareAnalysisRequest,
    MalwareAnalysisResponse,
    ErrorResponse
)
from api.utils.model_loader import get_malware_model
from models.malware_detection.model import Model as MalwareModel
from models.malware_detection.preprocessor import Preprocessor as MalwarePreprocessor

# Configure logging
logger = logging.getLogger("defensys-api.malware")

# Create router
router = APIRouter()

# Initialize preprocessor
malware_preprocessor = MalwarePreprocessor()

# Config
MAX_FILE_SIZE = 100 * 1024 * 1024  # 100 MB
ALLOWED_MIME_TYPES = [
    'application/x-msdownload',  # PE files
    'application/x-executable',  # ELF files
    'application/x-mach-binary', # Mach-O files
    'application/x-dosexec',     # DOS executables
    'application/octet-stream',  # Binary data
    'application/x-sharedlib',   # Shared libraries
    'application/zip',           # ZIP archives
    'application/x-rar-compressed', # RAR archives
    'application/java-archive',  # JAR files
    'application/vnd.microsoft.portable-executable', # PE files
    'application/pdf',           # PDF files can contain malware
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document', # DOCX
    'application/msword',        # DOC
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',      # XLSX
    'application/vnd.ms-excel',  # XLS
    'text/x-python',             # Python scripts
    'text/javascript',           # JavaScript files
    'text/x-php',                # PHP scripts
    'text/x-powershell',         # PowerShell scripts
    'text/x-shellscript',        # Shell scripts
]

def get_threat_level(score: float) -> str:
    """Convert malware score to threat level"""
    if score >= 0.9:
        return "Critical"
    elif score >= 0.7:
        return "High"
    elif score >= 0.4:
        return "Medium"
    else:
        return "Low"

def get_file_hashes(file_path: str) -> Dict[str, str]:
    """Calculate file hashes (MD5, SHA1, SHA256)"""
    md5 = hashlib.md5()
    sha1 = hashlib.sha1()
    sha256 = hashlib.sha256()
    
    with open(file_path, 'rb') as f:
        data = f.read()
        md5.update(data)
        sha1.update(data)
        sha256.update(data)
    
    return {
        'md5': md5.hexdigest(),
        'sha1': sha1.hexdigest(),
        'sha256': sha256.hexdigest()
    }

def get_mime_type(file_path: str) -> str:
    """Get MIME type of a file using python-magic or fallback to simple checks"""
    try:
        import magic
        mime = magic.Magic(mime=True)
        return mime.from_file(file_path)
    except (ImportError, AttributeError):
        # Fallback to simple extension-based mime type detection
        import mimetypes
        mimetypes.init()
        mime_type, _ = mimetypes.guess_type(file_path)
        
        if mime_type:
            return mime_type
        
        # Default fallbacks based on extension
        extension = file_path.lower().split('.')[-1] if '.' in file_path else ''
        extension_map = {
            'exe': 'application/x-msdownload',
            'dll': 'application/x-msdownload',
            'so': 'application/x-sharedlib',
            'elf': 'application/x-executable',
            'bin': 'application/octet-stream',
            'zip': 'application/zip',
            'rar': 'application/x-rar-compressed',
            'jar': 'application/java-archive',
            'pdf': 'application/pdf',
            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'doc': 'application/msword',
            'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'xls': 'application/vnd.ms-excel',
            'py': 'text/x-python',
            'js': 'text/javascript',
            'php': 'text/x-php',
            'sh': 'text/x-shellscript',
        }
        
        return extension_map.get(extension, 'application/octet-stream')

def extract_indicators_of_compromise(file_path: str) -> List[Dict[str, Any]]:
    """Extract potential indicators of compromise from the file"""
    indicators = []
    
    try:
        # Get file type
        mime_type = get_mime_type(file_path)
        
        # Get strings that might be interesting (URLs, IPs, suspicious strings)
        import re
        from collections import Counter
        
        # Read file content
        with open(file_path, 'rb') as f:
            content = f.read()
        
        # Convert binary to string, ignoring errors
        text_content = content.decode('ascii', errors='ignore')
        
        # Find URLs
        url_pattern = r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+'
        urls = re.findall(url_pattern, text_content)
        if urls:
            indicators.append({
                'type': 'url',
                'values': urls[:20],  # Limit to 20 URLs
                'count': len(urls)
            })
        
        # Find IP addresses
        ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
        ips = re.findall(ip_pattern, text_content)
        if ips:
            indicators.append({
                'type': 'ip',
                'values': ips[:20],  # Limit to 20 IPs
                'count': len(ips)
            })
        
        # Find potential domains
        domain_pattern = r'\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}\b'
        domains = re.findall(domain_pattern, text_content)
        if domains:
            indicators.append({
                'type': 'domain',
                'values': domains[:20],  # Limit to 20 domains
                'count': len(domains)
            })
        
        # Check for common malware strings
        suspicious_strings = [
            'CreateRemoteThread', 'VirtualAlloc', 'WriteProcessMemory',
            'ShellExecute', 'GetProcAddress', 'LoadLibrary', 'WinExec',
            'CreateProcess', 'WSASocket', 'InternetOpen', 'HttpSendRequest',
            'system32', 'cmd.exe', 'powershell', 'rundll32', 'regsvr32',
            'WScript.Shell', 'Downloads', 'AppData', 'Temp', 'registry',
            'botnet', 'backdoor', 'trojan', 'rootkit', 'keylogger', 'spyware',
            'ransom', 'encrypt', 'inject', 'exploit'
        ]
        
        found_suspicious = []
        for s in suspicious_strings:
            if s.lower() in text_content.lower():
                found_suspicious.append(s)
        
        if found_suspicious:
            indicators.append({
                'type': 'suspicious_string',
                'values': found_suspicious,
                'count': len(found_suspicious)
            })
        
        # PE file specific indicators
        if mime_type in ['application/x-dosexec', 'application/x-msdownload', 'application/vnd.microsoft.portable-executable']:
            try:
                # Try to import pefile, but it's optional
                try:
                    import pefile
                    pe_available = True
                except ImportError:
                    pe_available = False
                    logger.warning("pefile module not available, skipping detailed PE analysis")
                    indicators.append({
                        'type': 'info',
                        'value': 'PE file detected but detailed analysis unavailable (pefile module not installed)'
                    })
                
                if pe_available:
                    pe = pefile.PE(file_path)
                    
                    # Get imported DLLs
                    imports = []
                    if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                        for entry in pe.DIRECTORY_ENTRY_IMPORT:
                            dll_name = entry.dll.decode('utf-8', errors='ignore')
                            imports.append(dll_name)
                    
                    if imports:
                        indicators.append({
                            'type': 'imported_dll',
                            'values': imports[:20],
                            'count': len(imports)
                        })
                    
                    # Get sections
                    sections = []
                    if hasattr(pe, 'sections'):
                        for section in pe.sections:
                            section_name = section.Name.decode('utf-8', errors='ignore').strip('\x00')
                            entropy = section.get_entropy()
                            sections.append({
                                'name': section_name,
                                'entropy': entropy,
                                'size': section.SizeOfRawData
                            })
                    
                    if sections:
                        indicators.append({
                            'type': 'pe_section',
                            'values': sections[:10],
                            'count': len(sections)
                        })
                
            except Exception as e:
                logger.warning(f"Error analyzing PE file: {str(e)}")
                indicators.append({
                    'type': 'error',
                    'value': f"PE analysis error: {str(e)}"
                })
        
        return indicators
        
    except Exception as e:
        logger.warning(f"Error extracting indicators: {str(e)}")
        return [{'type': 'error', 'value': str(e)}]

@router.post(
    "/analyze",
    response_model=MalwareAnalysisResponse,
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    },
    summary="Analyze a file for malware",
    description="Upload and analyze a file for malware using machine learning."
)
async def analyze_file(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(..., description="File to analyze"),
    scan_type: str = Form("full", description="Type of scan: quick, full, or deep"),
    extract_indicators: bool = Form(True, description="Extract indicators of compromise")
):
    """
    Analyze a file for malware.
    
    This endpoint accepts file uploads and analyzes them for malware using
    machine learning. It supports different scan types and can extract
    indicators of compromise.
    """
    start_time = time.time()
    
    # Validate scan type
    if scan_type.lower() not in ["quick", "full", "deep"]:
        raise HTTPException(
            status_code=400,
            detail="Invalid scan type. Must be 'quick', 'full', or 'deep'."
        )
    
    # Create a temporary file
    temp_dir = tempfile.mkdtemp()
    temp_file_path = os.path.join(temp_dir, file.filename)
    
    try:
        # Save uploaded file to temporary location
        try:
            with open(temp_file_path, "wb") as f:
                # Read in chunks to handle large files and check size
                file_size = 0
                while chunk := await file.read(1024 * 1024):  # 1MB chunks
                    file_size += len(chunk)
                    if file_size > MAX_FILE_SIZE:
                        raise HTTPException(
                            status_code=400,
                            detail=f"File too large. Maximum size is {MAX_FILE_SIZE / (1024 * 1024)} MB."
                        )
                    f.write(chunk)
                
            # If file is empty
            if file_size == 0:
                raise HTTPException(
                    status_code=400,
                    detail="Empty file provided."
                )
        except Exception as e:
            if not isinstance(e, HTTPException):
                logger.error(f"Error saving uploaded file: {str(e)}", exc_info=True)
                raise HTTPException(
                    status_code=500,
                    detail=f"Error processing uploaded file: {str(e)}"
                )
            raise
        
        # Get file information
        file_mime_type = get_mime_type(temp_file_path)
        
        # Validate MIME type
        if ALLOWED_MIME_TYPES and file_mime_type not in ALLOWED_MIME_TYPES:
            raise HTTPException(
                status_code=400,
                detail=f"Unsupported file type: {file_mime_type}"
            )
        
        # Calculate file hashes
        hashes = get_file_hashes(temp_file_path)
        
        # Extract indicators of compromise if requested
        ioc_results = None
        if extract_indicators:
            ioc_results = extract_indicators_of_compromise(temp_file_path)
        
        # Get the malware model
        model = get_malware_model()
        
        # Preprocess the file for analysis
        features = malware_preprocessor.extract_features_from_file(temp_file_path)
        
        # Make prediction
        prediction = model.predict_with_details(features)
        
        # Calculate scan time
        scan_time = time.time() - start_time
        
        # Prepare analysis results
        analysis_results = {
            "file_info": {
                "mime_type": file_mime_type,
                "size": file_size,
                "hash_md5": hashes['md5'],
                "hash_sha1": hashes['sha1'],
                "hash_sha256": hashes['sha256']
            },
            "scan_info": {
                "scan_type": scan_type,
                "duration": scan_time,
                "engine_version": model.get_version() if hasattr(model, "get_version") else "unknown"
            },
            "prediction": {
                "is_malicious": prediction["is_malicious"],
                "confidence": prediction["confidence"],
                "malware_type": prediction.get("malware_type", "Unknown")
            }
        }
        
        # Create response
        response = MalwareAnalysisResponse(
            status="success",
            message="File analysis completed",
            filename=file.filename,
            file_size=file_size,
            file_type=file_mime_type,
            sha256=hashes['sha256'],
            md5=hashes['md5'],
            is_malicious=prediction["is_malicious"],
            confidence=prediction["confidence"],
            threat_level=get_threat_level(prediction["confidence"]),
            threat_type=prediction.get("malware_type", "Unknown") if prediction["is_malicious"] else None,
            analysis=analysis_results,
            indicators_of_compromise=ioc_results,
            scan_time=scan_time
        )
        
        # Log prediction in background
        background_tasks.add_task(
            logger.info,
            f"Malware prediction: File={file.filename}, is_malicious={prediction['is_malicious']}, confidence={prediction['confidence']:.4f}"
        )
        
        return response
        
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        logger.error(f"Error analyzing file {file.filename}: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Error analyzing file: {str(e)}"
        )
    finally:
        # Clean up temporary files
        try:
            shutil.rmtree(temp_dir)
        except Exception as e:
            logger.warning(f"Error cleaning up temporary files: {str(e)}")

@router.post(
    "/batch",
    response_model=List[MalwareAnalysisResponse],
    responses={
        400: {"model": ErrorResponse, "description": "Bad request"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    },
    summary="Batch analyze multiple files",
    description="Upload and analyze multiple files in a single request."
)
async def batch_analyze(
    request: Request,
    background_tasks: BackgroundTasks,
    files: List[UploadFile] = File(..., description="Files to analyze"),
    scan_type: str = Form("quick", description="Type of scan: quick, full, or deep"),
    extract_indicators: bool = Form(False, description="Extract indicators of compromise")
):
    """
    Analyze multiple files for malware in a single request.
    
    This endpoint allows uploading multiple files for efficient batch processing.
    It uses the same analysis engine as the single file endpoint but optimizes for
    multiple files.
    """
    if len(files) > 10:
        raise HTTPException(
            status_code=400,
            detail="Maximum of 10 files can be analyzed in a single batch request"
        )
    
    results = []
    
    for file in files:
        try:
            # Use the single file analysis endpoint for each file
            result = await analyze_file(
                background_tasks=background_tasks,
                file=file,
                scan_type=scan_type,
                extract_indicators=extract_indicators
            )
            results.append(result)
        except HTTPException as e:
            # If one file fails, add error response but continue with others
            logger.warning(f"Error analyzing file {file.filename} in batch: {str(e)}")
            results.append(
                MalwareAnalysisResponse(
                    status="error",
                    message=f"Error analyzing file: {e.detail}",
                    filename=file.filename,
                    file_size=0,
                    file_type="unknown",
                    sha256="",
                    md5="",
                    is_malicious=False,
                    confidence=0.0,
                    threat_level="Unknown",
                    analysis={},
                    scan_time=0.0
                )
            )
    
    return results
