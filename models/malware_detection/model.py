import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense, Dropout, BatchNormalization
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.preprocessing import StandardScaler
import os
import pickle

class Model:
    def __init__(self):
        """Initialize the malware detection model."""
        self.model = None
        self.scaler = StandardScaler()
        self.model_ready = False
        
    def build_model(self, input_dim):
        """Build the neural network model architecture.
        
        Args:
            input_dim: Dimension of the input features
            
        Returns:
            Compiled Keras model
        """
        model = Sequential([
            Dense(128, activation='relu', input_shape=(input_dim,)),
            BatchNormalization(),
            Dropout(0.3),
            Dense(64, activation='relu'),
            BatchNormalization(),
            Dropout(0.2),
            Dense(32, activation='relu'),
            BatchNormalization(),
            Dense(1, activation='sigmoid')
        ])
        
        model.compile(
            optimizer='adam',
            loss='binary_crossentropy',
            metrics=['accuracy']
        )
        
        return model

    def train(self, X, y, validation_split=0.2, epochs=50, batch_size=32):
        """Train the malware detection model.
        
        Args:
            X: Features array or DataFrame
            y: Target labels
            validation_split: Fraction of data to use for validation
            epochs: Number of training epochs
            batch_size: Batch size for training
            
        Returns:
            self: The trained model instance
        """
        print(f"Training malware detection model with {len(X)} samples")
        
        # Convert to numpy array if DataFrame
        if isinstance(X, pd.DataFrame):
            X = X.values
        if isinstance(y, pd.Series):
            y = y.values
            
        # Scale the features
        X_scaled = self.scaler.fit_transform(X)
        
        # Build the model
        input_dim = X.shape[1]
        self.model = self.build_model(input_dim)
        
        # Define callbacks
        callbacks = [
            EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True),
            ModelCheckpoint('temp_best_model.h5', save_best_only=True, monitor='val_loss')
        ]
        
        # Train the model
        history = self.model.fit(
            X_scaled, y,
            validation_split=validation_split,
            epochs=epochs,
            batch_size=batch_size,
            callbacks=callbacks,
            verbose=1
        )
        
        # Clean up temporary files
        if os.path.exists('temp_best_model.h5'):
            os.remove('temp_best_model.h5')
            
        self.model_ready = True
        return self

    def predict(self, X):
        """Make predictions with the malware detection model.
        
        Args:
            X: Features to predict on
            
        Returns:
            np.array: Prediction probabilities [[prob_benign, prob_malware]]
        """
        if not self.model_ready:
            raise ValueError("Model has not been trained or loaded yet")
        
        # Convert to numpy array if DataFrame
        if isinstance(X, pd.DataFrame):
            X = X.values
        
        # Scale the features
        X_scaled = self.scaler.transform(X)
        
        # Get prediction probabilities
        try:
            # Get raw probabilities (0 to 1 for malware)
            probs = self.model.predict(X_scaled)
            
            # Convert to format [[prob_benign, prob_malware]]
            result = np.hstack((1-probs, probs))
            return result
        except Exception as e:
            print(f"Error in prediction: {e}")
            # Return a safe default if prediction fails
            return np.array([[0.99, 0.01]])  # [benign, malware]

    def evaluate(self, X, y):
        """Evaluate the model on test data.
        
        Args:
            X: Test features
            y: True labels
            
        Returns:
            dict: Dictionary with evaluation metrics
        """
        if not self.model_ready:
            raise ValueError("Model has not been trained or loaded yet")
        
        # Convert to numpy array if DataFrame
        if isinstance(X, pd.DataFrame):
            X = X.values
        if isinstance(y, pd.Series):
            y = y.values
            
        # Scale the features
        X_scaled = self.scaler.transform(X)
        
        # Evaluate the model
        loss, accuracy = self.model.evaluate(X_scaled, y, verbose=0)
        
        return {
            'loss': loss,
            'accuracy': accuracy
        }

    def save(self, path):
        """Save the model to disk.
        
        Args:
            path: Path to save the model to
        """
        if not self.model_ready:
            raise ValueError("Model has not been trained or loaded yet")
            
        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(path), exist_ok=True)
        
        # Save the Keras model
        self.model.save(path)
        
        # Save the scaler in the same directory
        scaler_path = os.path.join(os.path.dirname(path), 'scaler.pkl')
        with open(scaler_path, 'wb') as f:
            pickle.dump(self.scaler, f)
        
        print(f"Model saved to {path}")
        print(f"Scaler saved to {scaler_path}")

    def load(self, path):
        """Load the model from disk.
        
        Args:
            path: Path to load the model from
        """
        if not os.path.exists(path):
            raise FileNotFoundError(f"Model file not found at {path}")
        
        # Load the Keras model
        self.model = load_model(path)
        
        # Load the scaler
        scaler_path = os.path.join(os.path.dirname(path), 'scaler.pkl')
        if os.path.exists(scaler_path):
            with open(scaler_path, 'rb') as f:
                self.scaler = pickle.load(f)
        
        self.model_ready = True
        print(f"Model loaded from {path}")
